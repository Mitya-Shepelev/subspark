# Архитектура обработки видео в SubSpark

## Текущее состояние (Синхронная обработка)

**Проблема:** FFmpeg запускается синхронно при загрузке видео, что:
- Блокирует HTTP запрос пользователя (пользователь ждет 10-30 секунд)
- Нагружает CPU веб-сервера (может "положить" сайт при множестве загрузок)
- Не масштабируется (один сервер обрабатывает все)

**Текущий поток:**
```
User Upload → Web Server → FFmpeg (sync) → Save to DB → Response
                ↓ (блокирует)
            User waits...
```

## Решение: Асинхронная обработка через Job Queue

### Архитектура

```
┌─────────────┐
│   User      │
│  Upload     │
└──────┬──────┘
       │
       ▼
┌──────────────────┐    1. Save original file
│   Web Server     │────────────────────┐
│   (subspark-app) │                    │
└──────────────────┘                    ▼
       │                         ┌──────────────┐
       │ 2. Add job to queue     │   Storage    │
       └────────────────────────▶│  (Selectel)  │
                                 └──────────────┘
       ▲                                │
       │ 5. Update DB status            │
       │                                │
┌──────────────────┐                    │
│  Redis Queue     │                    │
│  (job storage)   │                    │
└──────────────────┘                    │
       ▲                                │
       │ 3. Get job                     │
       │                                │
┌──────────────────┐                    │
│  Video Worker    │                    │
│  (FFmpeg)        │◀───────────────────┘
└──────────────────┘    4. Process & upload
```

### Преимущества

1. ✅ **Быстрый ответ пользователю** - сохранили файл и ответили за 1-2 секунды
2. ✅ **Разгрузка веб-сервера** - FFmpeg работает на отдельном сервере/контейнере
3. ✅ **Масштабируемость** - можно запустить 5-10 workers для параллельной обработки
4. ✅ **Отказоустойчивость** - если worker упал, задача остается в очереди
5. ✅ **Мониторинг** - видно сколько задач в очереди, сколько обработано, сколько провалено

## Созданная инфраструктура

### 1. Worker контейнер
- Расположение: `/worker/`
- Dockerfile: `/worker/Dockerfile`
- Entry point: `/worker/worker.php`
- Обрабатывает 3 типа задач:
  - `convert` - конвертация видео в MP4
  - `thumbnail` - создание миниатюры
  - `reel_blur` - создание вертикального видео с размытием

### 2. Job Queue классы
- `VideoJob.php` - модель задачи
- `VideoQueue.php` - работа с Redis очередью
- `VideoWorker.php` - обработчик задач
- `video_queue_helper.php` - хелперы для интеграции с приложением

### 3. Docker конфигурация
- `docker-compose.yml` - добавлен сервис `video-worker`
- Ограничения ресурсов: 2 CPU, 2GB RAM
- Подключен к Redis и shared uploads volume

## Как активировать асинхронную обработку

### Шаг 1: Изменения в БД

Добавить поле `processing_status` в таблицы видео:

```sql
-- Для постов с видео
ALTER TABLE i_posts
ADD COLUMN processing_status ENUM('pending', 'processing', 'completed', 'failed')
DEFAULT 'completed' AFTER iuid;

ADD COLUMN processing_job_id VARCHAR(50) DEFAULT NULL AFTER processing_status;

-- Для reels
ALTER TABLE i_files
ADD COLUMN processing_status ENUM('pending', 'processing', 'completed', 'failed')
DEFAULT 'completed' AFTER iuid;

ADD COLUMN processing_job_id VARCHAR(50) DEFAULT NULL AFTER processing_status;
```

### Шаг 2: Изменения в коде загрузки

Заменить синхронную обработку в `/requests/upload_chunk.php`:

```php
// БЫЛО (синхронно):
$reelsPath = convertVideoToBlurredReelsFormat($ffmpegBin, $finalPath, $reelsDir);

// СТАЛО (асинхронно):
require_once __DIR__ . '/../includes/video_queue_helper.php';

if (isAsyncVideoProcessingAvailable() && getenv('USE_ASYNC_VIDEO_PROCESSING') == '1') {
    // Сохранить оригинальное видео
    $jobId = queueBlurredReelCreation($finalPath, $reelsDir, $maxVideoDuration);

    // Сохранить в БД со статусом "processing"
    DB::exec("INSERT INTO i_files
        (user_id, original_path, processing_status, processing_job_id, upload_time)
        VALUES (?, ?, 'processing', ?, ?)",
        [$userID, $finalPath, $jobId, time()]
    );

    // Вернуть ответ сразу
    echo json_encode([
        'success' => true,
        'status' => 'processing',
        'jobId' => $jobId
    ]);
} else {
    // Fallback к синхронной обработке
    $reelsPath = convertVideoToBlurredReelsFormat($ffmpegBin, $finalPath, $reelsDir);
    // ... обычное сохранение
}
```

### Шаг 3: Добавить polling на фронтенде

В `/themes/default/js/inora.js`:

```javascript
// После загрузки проверять статус обработки
function checkProcessingStatus(jobId) {
    $.post('/requests/request.php', {
        f: 'checkVideoStatus',
        jobId: jobId
    }, function(response) {
        if (response.status === 'completed') {
            // Показать видео
            location.reload();
        } else if (response.status === 'processing') {
            // Проверить снова через 2 секунды
            setTimeout(() => checkProcessingStatus(jobId), 2000);
        } else if (response.status === 'failed') {
            alert('Video processing failed');
        }
    });
}
```

### Шаг 4: Обновление статуса из worker

Добавить в `VideoWorker.php` после успешной обработки:

```php
private function updateDatabaseStatus(string $jobId, string $status, array $paths = []): void
{
    // Подключение к MySQL
    $dbHost = getenv('DB_HOST') ?: 'localhost';
    $dbName = getenv('DB_NAME') ?: 'subspark';
    $dbUser = getenv('DB_USER') ?: 'subspark';
    $dbPass = getenv('DB_PASSWORD') ?: '';

    $pdo = new PDO("mysql:host=$dbHost;dbname=$dbName", $dbUser, $dbPass);

    // Обновить статус
    $stmt = $pdo->prepare("
        UPDATE i_files
        SET processing_status = ?,
            uploaded_file_path = ?,
            upload_tumbnail_file_path = ?
        WHERE processing_job_id = ?
    ");

    $stmt->execute([
        $status,
        $paths['video'] ?? null,
        $paths['thumbnail'] ?? null,
        $jobId
    ]);
}
```

### Шаг 5: Запустить worker

```bash
# В docker-compose.yml раскомментировать video-worker сервис
docker-compose up -d video-worker

# Проверить логи
docker logs -f subspark-video-worker
```

## Масштабирование

### Один сервер, несколько workers

```bash
docker-compose up -d --scale video-worker=3
```

### Несколько серверов

**Сервер 1** (веб-приложение + Redis):
```yaml
# docker-compose.yml - только app и redis
```

**Сервер 2, 3, 4** (только workers):
```bash
docker run -d --name worker1 \
  -e REDIS_HOST=redis.example.com \
  -e REDIS_PORT=6379 \
  -e REDIS_PASSWORD=your_password \
  -v /mnt/shared-storage:/app/uploads \
  subspark-video-worker
```

## Мониторинг

### Статистика очереди

```php
require_once 'includes/video_queue_helper.php';

$stats = getVideoQueueStats();
echo "В очереди: {$stats['pending']}\n";
echo "Обрабатывается: {$stats['processing']}\n";
echo "Завершено: {$stats['completed']}\n";
echo "Провалено: {$stats['failed']}\n";
```

### Dashboard для админки

Создать страницу в админ панели `/admin/default/sources/contents/videoQueue.php`:

```php
$stats = getVideoQueueStats();
// Показать графики, список провальных задач и т.д.
```

### Alerts при перегрузке

```php
// Отправить уведомление если в очереди > 100 задач
if ($stats['pending'] > 100) {
    // Отправить email админу
    mail($adminEmail, 'Video queue overload', "Pending jobs: {$stats['pending']}");
}
```

## Стоимость и производительность

### Текущая (синхронная):
- 1 сервер (4 CPU, 8GB RAM): ~50-100 пользователей онлайн
- При 10 одновременных загрузках видео: сайт зависает

### С асинхронной обработкой:
- 1 веб-сервер (2 CPU, 4GB RAM): ~500+ пользователей онлайн
- 1-3 worker сервера (4 CPU каждый): обрабатывают 100+ видео параллельно
- Workers можно запускать на дешевых серверах без SSD

## Roadmap

1. [x] Создать инфраструктуру worker (DONE)
2. [x] Добавить классы Job Queue (DONE)
3. [x] Создать Dockerfile для worker (DONE)
4. [ ] Изменить схему БД (добавить processing_status)
5. [ ] Обновить код загрузки для использования очереди
6. [ ] Добавить polling на фронтенде
7. [ ] Создать dashboard мониторинга в админке
8. [ ] Тестирование на production
9. [ ] Настроить автомасштабирование workers

## Альтернативный подход: Hybrid

Можно использовать "гибридный" режим:
- Малые видео (<10MB, <30сек) - синхронно (быстро)
- Большие видео (>10MB, >30сек) - асинхронно (не блокирует)

Это позволит не менять фронтенд для простых случаев.

## Заключение

Инфраструктура готова, но **не активирована по умолчанию**, чтобы не ломать текущую функциональность.

Для активации потребуется:
1. Изменения в БД (processing_status)
2. Изменения в коде загрузки (использовать очередь)
3. Изменения на фронтенде (polling статуса)

Это займет ~2-3 дня разработки + тестирование.
